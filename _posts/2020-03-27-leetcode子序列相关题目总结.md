---
title: leetcode子序列相关题目总结
date:  2020-03-27 11:19:13 +0800
category: leetcode 
tags: leetcode subsequence
excerpt: 子序列相关题目总结
comment: True
mathjax: True
---

### 1. 所有子序列 （leetcode78/90）

子序列个数:(动态规划状态转移方程为) $ dp[k+1] = dp[k] * 2 $

解释：例如序列$\lbrace a,b,c \rbrace$, $dp[0]=2$，所有的子序列为 $\lbrace "", "a" \rbrace$; dp[1] = 4, 包含子序列为$\lbrace "", "a", "b", "ab" \rbrace$. 也就是相当于把字符 $b$ 加入到所有的 $dp[0]$ 对应的子序列中，然后与先前的子序列求并组成当前状态的所有子序列。

leetcode78: 求所有的子序列（集合中不包含重复元素）

```
vector<vector<int>> subsets(vector<int>& nums) {
    vector<vector<int>> results;
    vector<int> temp;
    results.push_back(temp);
    for(int num:nums){
        int size = results.size();
        for(int i=0;i<size;i++){
            temp = results[i];
            temp.push_back(num);
            results.push_back(temp);
        }
    }
    return results;
}
```

leetcode90:求所有不重复的子序列（集合中包含重复元素）

```
```


### 2. 最长上升子序列 （leetcode 300）

#### 2.1. 最长上升子序列的元素个数

a. $O(n^2)$ 算法

```
    int m = nums.size();
    if(m==0) return 0;
    vector<int> dp(m, 0);

    for(int i=0;i<nums.size();i++){
        //初始化
        dp[i] = 1;
        for(int j=0;j<i;j++){
            if(nums[i]>nums[j]) dp[i] = max(dp[i], dp[j]+1);
        }
    }

    return *max_element(dp.begin(), dp.end());
```

b. $O(nlogn)$ 优化

定义一个dp数组。数组中存放的数据（i,dp[i]）表示：长度为i的上升子序列的末尾值。通过定义可以知道dp数组是严格递增的序列。

dp数组的更新：

1. 如果nums数组中元素大于dp末尾元素，则上升子序列长度+1;

2. 如果nums数组中元素小于等于dp末尾元素，则上升子序列长度不变。
并且更新dp数组中第一个大于等于nums元素对应的上升子序列的末尾元素。

```
    vector<int> dp;
    dp.push_back(nums[0]);

    for(int i = 1; i<nums.size(); i++){

        if(dp.back()<nums[i]) dp.push_back(nums[i]);
        else{
            //寻找序列中第一个大于等于nums[i]的元素
            *lower_bound(dp.begin(), dp.end(), nums[i])=nums[i];
        }   
    }
    return dp.size();
```

#### 2.2. 最长上升子序列的元素



### 3. 最长和谐子序列 （leetcode 594）

统计元素个数，然后判断差值为1的元素个数。

```
int findLHS(vector<int>& nums) {
    map<int,int,less<int>> hashmap;
    for(int i=0;i<nums.size();i++){
        hashmap[nums[i]]++;
    }
    int maxnum = 0;
    for(auto iter=hashmap.begin(); iter!=hashmap.end();iter++){
        //cout<<iter->first<<" "<<iter->second<<endl;
        if(hashmap.count(iter->first+1)!=0)
            maxnum = max(maxnum, iter->second+hashmap[iter->first+1]);
    }
    return maxnum;
}
```

### 4. 最长公共子序列 （1143）

动态规划：

$$
dp[i,j] = \left\{
    \begin{aligned}
    &0 &\text{if} \quad i=0 \quad \text{or} \quad j=0\\
    &dp[i-1, j-1] + 1 &\text {if} \quad a_i = b_j \\
    &\max \lbrace dp[i,j-1], dp[i-1,j]\rbrace &\text {if} \quad a_i \ne b_j
    \end{aligned}
    \right.
$$

c++代码实现：

```
int longestCommonSubsequence(string text1, string text2) {

    int m = text1.size();
    int n = text2.size();

    vector<vector<int>> dp(m+1, vector<int>(n+1,0));
    int i = 0;
    int j = 0;
    for(i = 1;i<=m;i++){
        for(j = 1;j<=n;j++){
            if(text1[i-1] == text2[j-1]){
                dp[i][j] = dp[i-1][j-1] + 1;
            }else{
                dp[i][j] = max(dp[i][j-1], dp[i-1][j]);
            }
        }
    }
    return dp[i-1][j-1];
}
```

内存优化版本：




### 5. 不同的子序列个数（Leetcode 115/940）

动态规划问题：

$$
\text{dp}[k+1] = \text{dp}[k] * 2 - \text{dp}[\text{last}[a_{k+1}] - 1]
$$

其中 $\text{last}[a_{k+1}]$ 表示 序列中最近一次出现 $a_{k+1}$ 的位置。

leetcode 940 代码实现：

```
```


### 6. 乘积最大的子序列（leetcode 152）

动态规划

```
    int maxProduct(vector<int>& nums) {
        int maxValue = nums[0];
        // vector<int> dp(nums.size(), 0);
        // vector<int> dp_min(nums.size(), 0);
        int dp_max = nums[0];
        int dp_min = nums[0];
        for(int i=1;i<nums.size();i++){
            if(nums[i]<0) swap(dp_max,dp_min);
            dp_max = max(dp_max*nums[i], nums[i]);
            dp_min = min(dp_min*nums[i], nums[i]);

            maxValue = max(dp_max, maxValue);
        }
        return maxValue;
    }
```

### 

### 实战题目

#### Leetcode 354 俄罗斯套娃信封问题（hard）

排序 + 最长子序列



<center><font size='5'><b>Reference</b></font></center>

[1]. 最长上升子序列 $O(nlogn)$ 详解 https://blog.csdn.net/shuangde800/article/details/7474903